//Variaveis fixas - Não alterar.
def GIT_USER = "git-access"
def OWNER_NAME = "${env.JOB_NAME}".split("/") [0]
def REPO_NAME = "${env.JOB_NAME}".split("/") [1]
def K8S_USER = "devops"
def K8S_CREDENTIAL = "k8s-access"
def GIT_URL = "https://github.com"
def DOCKER_URL = "dockerhub.com"
def DOCKER_REGISTRY = "${DOCKER_URL}/${OWNER_NAME}-docker/"
def webhookUrl = "#slack-channler or #teams-channel"
def tags
def tagName
def k8s_server
def namespaces

node {    
    if (env.BRANCH_NAME == 'master' || env.BRANCH_NAME == 'uat' || env.BRANCH_NAME == 'dev' ){
        git credentialsId: "${GIT_USER}", url: "${GIT_URL}/${OWNER_NAME}/${REPO_NAME}.git"
        tags = sh (script: 'git tag --sort=-v:refname', returnStdout: true).trim()
        sshagent(credentials: [K8S_CREDENTIAL]) {
            if (env.BRANCH_NAME == 'master'){ 
                k8s_server = '192.168.0.1' 
            } else if (env.BRANCH_NAME == 'uat') {
                k8s_server = '192.168.0.2' 
            } else if (env.BRANCH_NAME == 'dev'){
                k8s_server = '192.168.0.3'
            } 
            def k8snamespace = "sudo kubectl get namespace -o=custom-columns=NAME:.metadata.name"
            namespaces = sh (script: "ssh -v -oStrictHostKeyChecking=no ${K8S_USER}@${k8s_server} ${k8snamespace}", returnStdout: true).trim()
        }
    }
}    

pipeline {
    agent any
    environment{
        registry = "https://${DOCKER_REGISTRY}"
        registryCredential = "${ARTIFACTORY_CREDENTIAL}"        
    }
    options {
        ansiColor('css')
        timestamps()
    }
    stages{
        stage('Building pipeline'){
            steps{
                echo "Running Build - ${env.BUILD_TAG} on ${env.JENKINS_URL}"
            }
        }
        stage('Change to release'){
            when{ expression { return env.CHANGE_TARGET == 'master' }}
            steps {
                
                script {                    
                    // Remover chamada do Credentials
                    def response = httpRequest "${GITI_URL}/Credential/${GITI_TOKEN_ORG}"
                    def data = readJSON text: response.content

                    response = httpRequest "${GITI_URL}/GITI/ChangeRelease/${params.Versão}/${OWNER_NAME}/${data.gitToken}/${REPO_NAME}/false"
                    data = readJSON text: response.content

                    if(data.warnings.size() > 0){
                        String result = data.resultMessage + "\n"
                        for(String item : data.warnings){
                            result += item + "\n"
                        }
                        autoCancelled = true
                        error (result)
                    } 
                }
            }    
        }        
        stage('Docker build image'){
            when{ expression { return env.CHANGE_TARGET == 'dev'}}
            steps{
                script{
                    withCredentials([usernamePassword(credentialsId: "${ARTIFACTORY_CREDENTIAL}", passwordVariable: 'Pass', usernameVariable: 'User')]) {
                        sh "docker login -u '${ARTIFACTORY_CREDENTIAL}' -p '$Pass' ${DOCKER_URL}"
                    }
                    dockerImage = docker.build "${DOCKER_REGISTRY}${REPO_NAME}"
                }
            }
        }
        stage('Upload Docker Image') {
            when{ expression { return env.CHANGE_TARGET == 'dev'}}
            steps{
                script {
                    withCredentials([usernamePassword(credentialsId: "${ARTIFACTORY_CREDENTIAL}", passwordVariable: 'Pass', usernameVariable: 'User')]) {
                        sh "docker login -u '${ARTIFACTORY_CREDENTIAL}' -p '$Pass' ${DOCKER_URL}"
                    }
                    docker.withRegistry( registry , registryCredential ) {
                        dockerImage.push("${tagName}")
                    }
                }
            }
        }       
        stage('Deploy to Kubernetes'){
            when{ expression { return env.BRANCH_NAME == 'dev' || env.BRANCH_NAME == 'uat' || env.BRANCH_NAME == 'master'}}
            steps{ 
                sshagent(credentials: [K8S_CREDENTIAL]) {
				    script{
                        if (env.BRANCH_NAME == 'master'){ 
                            k8s_server = '192.168.0.1' 
                        } else if (env.BRANCH_NAME == 'uat') {
                            k8s_server = '192.168.0.2' 
                        } else if (env.BRANCH_NAME == 'dev'){
                            k8s_server = '192.168.0.3'
                        } else {
                            echo "Nenhum servidor selecionado"
                            return
                        }
                        sh "cp deploy.yaml ${REPO_NAME}.yaml"
                        sh "sed -i 's/#namerepo#/${REPO_NAME}/g' ${REPO_NAME}.yaml"
                        sh "sed -i 's/#version#/${params.Versão}/g' ${REPO_NAME}.yaml"
                        sh "sed -i 's/#namespace#/${params.Ambiente}/g' ${REPO_NAME}.yaml"
                        sh "cat ${REPO_NAME}.yaml"    
                        def k8sCMD = "sudo kubectl apply -f ${REPO_NAME}.yaml"
                        sh "scp ${REPO_NAME}.yaml ${K8S_USER}@${k8s_server}:/home/${K8S_USER}/${REPO_NAME}.yaml"
                        sh "ssh -v -oStrictHostKeyChecking=no ${K8S_USER}@${k8s_server} ${k8sCMD}"
				   }
				}
            }
        }                                              
        stage('Finishing Pipeline') {
            steps {
                echo "Finished - ${env.BUILD_TAG} on ${env.JENKINS_URL}"
            }
        }
    }
    post {
    always {
        deleteDir() /* clean up our workspace */
        office365ConnectorSend message: "Numero da Build: $BUILD_NUMBER "  +  " Branch: $BRANCH_NAME", status:"<span style='color:blue'>Iniciando pipeline</span>", color: '#0000FF', webhookUrl: "$webhookUrl"
    }
    success {
        echo 'Build finalizado com sucesso!'
        //office365ConnectorSend message: "teste", status:"sucesso", color: 'GREEN'
        office365ConnectorSend message: "Numero da Build: $BUILD_NUMBER "  +  " Branch: $BRANCH_NAME", status:"<span style='color:green'>Build finalizado com sucesso!</span>", color: '#008000', webhookUrl: "$webhookUrl"
    }
    failure {
        echo 'Erro! Favor verificar os logs.'
        deleteDir() /* clean up our workspace */
        office365ConnectorSend message: "Numero da Build: $BUILD_NUMBER "  +  " Branch: $BRANCH_NAME", status:"<span style='color:red'>Erro! Favor verificar os logs.</span>", color: '#ff0000', webhookUrl: "$webhookUrl"
        }
    }
}